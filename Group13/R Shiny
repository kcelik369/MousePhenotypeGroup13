library(shiny)
library(ggplot2)
library(dplyr)
library(tidyr)   # <-- needed for pivot_wider
library(plotly)

combined_data <- read.csv(
  "/Users/linakhalid/Downloads/Group13/combined_data.csv",
  stringsAsFactors = FALSE
)

score_data <- combined_data %>%
  transmute(
    GENE_SYMBOL = toupper(GENE_SYMBOL),   # gene
    PHENOTYPE   = PARAMETER_ID,           # phenotype tested
    P_VALUE     = as.numeric(PVALUE)      # p-value column
  ) %>%
  distinct()


ui <- fluidPage(
  titlePanel("IMPC Phenotype Dashboard"),
  
  sidebarLayout(
    sidebarPanel(
      h4("Filters"),
      selectInput("gene", "Select Gene:",
                  choices = sort(unique(score_data$GENE_SYMBOL))),
      selectInput("phen", "Select Phenotype:",
                  choices = sort(unique(score_data$PHENOTYPE))),
      sliderInput("cutoff", "P-value cutoff:",
                  min = 0, max = 1, value = 0.05)
    ),
    
    mainPanel(
      tabsetPanel(
        tabPanel("Per Gene View",
                 plotlyOutput("genePlot")
        ),
        tabPanel("Per Phenotype View",
                 plotlyOutput("phenPlot")
        ),
        tabPanel("Gene Clusters",
                 plotOutput("clusterPlot")
        )
      )
    )
  )
)


server <- function(input, output) {
  
  # Filter data for selected gene
  gene_data <- reactive({
    score_data %>% 
      filter(GENE_SYMBOL == input$gene)
  })
  
  # Filter data for selected phenotype
  phen_data <- reactive({
    score_data %>% 
      filter(PHENOTYPE == input$phen)
  })
  
  # Plot 1: Per Gene View
  output$genePlot <- renderPlotly({
    p <- ggplot(gene_data(), aes(
      x = seq_len(nrow(gene_data())),
      y = P_VALUE,
      text = paste("Phenotype:", PHENOTYPE,
                   "<br>P-value:", P_VALUE)
    )) +
      geom_point(size = 3) +
      geom_hline(yintercept = input$cutoff, linetype = "dashed") +
      labs(x = "Phenotype (index)", y = "P_VALUE") +
      theme_bw()
    
    ggplotly(p, tooltip = "text")
  })
  
  # Plot 2: Per Phenotype View
  output$phenPlot <- renderPlotly({
    p <- ggplot(phen_data(), aes(
      x = seq_len(nrow(phen_data())),
      y = P_VALUE,
      text = paste("Gene:", GENE_SYMBOL,
                   "<br>P-value:", P_VALUE)
    )) +
      geom_point(size = 3) +
      geom_hline(yintercept = input$cutoff, linetype = "dashed") +
      labs(x = "Gene (index)", y = "P_VALUE") +
      theme_bw()
    
    ggplotly(p, tooltip = "text")
  })
  
  # Plot 3: Gene Clusters (real heatmap of gene × phenotype p-values)
  output$clusterPlot <- renderPlot({
    library(dplyr)
    library(tidyr)
    
    # 1. Build wide matrix: genes x phenotypes
    wide_df <- score_data %>%
      group_by(GENE_SYMBOL, PHENOTYPE) %>%
      summarise(P_VALUE = mean(P_VALUE, na.rm = TRUE), .groups = "drop") %>%
      pivot_wider(names_from = PHENOTYPE, values_from = P_VALUE)
    
    # 2. Convert to numeric matrix
    mat <- as.data.frame(wide_df)
    rownames(mat) <- mat$GENE_SYMBOL
    mat$GENE_SYMBOL <- NULL
    mat <- as.matrix(mat)
    
    # 3. Replace missing values & transform to -log10(p)
    mat[is.na(mat)] <- median(mat, na.rm = TRUE)
    mat <- -log10(mat)
    
    # 4. Select top variable genes & phenotypes (20 × 20)
    gene_var <- apply(mat, 1, var)
    phen_var <- apply(mat, 2, var)
    
    top_genes <- names(sort(gene_var, decreasing = TRUE))[1:min(20, nrow(mat))]
    top_phens <- names(sort(phen_var, decreasing = TRUE))[1:min(20, ncol(mat))]
    
    mat_sub <- mat[top_genes, top_phens, drop = FALSE]
    
    # 5. Scale matrix to balance colours 
    mat_scaled <- scale(mat_sub)
    
    # 6. Draw heatmap 
    heatmap(mat_scaled,
            scale   = "none",
            col     = heat.colors(100),
            xlab    = "Phenotypes",
            ylab    = "Genes",
            margins = c(10, 10))
  })
  
  
}

shinyApp(ui = ui, server = server)
